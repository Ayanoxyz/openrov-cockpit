<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../mjpeg-video-webcomponents/mjpeg-video.html">
<link rel="import" href="../packet-video/packet-video.html">
<link rel="import" href="../orov-behaviors/orov-behavior.html">

<dom-module name="orov-video">
  <style>
  </style>
  <template>
    <template is="dom-if" if="{{displayPlayer(videoMimeType,'video/x-motion-jpeg')}}" iff="{{videoMimeType == 'video/x-motion-jpeg'}}">
    <mjpeg-video id="camera1" border='1' style='width: 100%; height:100%'
      menuState='on'
      src='{{videoSource}}'
      framespersecond='{{framesPerSecond}}'
      canvas='{{canvas}}'
      cors='false'
      showMenu='true'>
      <content></content>
     </mjpeg-video>
    </template>

    <template id="mp4template" is="dom-if" if="{{displayPlayer(videoMimeType,'video/mp4')}}" iff="{{videoMimeType == 'video/mp4'}}">
      <packet-video id="camera1" border='1' style='width: 100%; height:100%'
        menuState='on'
        src='{{videoSource}}'
        framespersecond='{{framesPerSecond}}'
        canvas='{{canvas}}'
        cors='false'
        showMenu='true'
        show-stats='{{showStats}}'>
      <content></content>
    </packet-video>
    </template>


  </template>
  <script>
    (function() {

(function (global) {

function CBuffer() {
	// handle cases where "new" keyword wasn't used
	if (!(this instanceof CBuffer)) {
		// multiple conditions need to be checked to properly emulate Array
		if (arguments.length > 1 || typeof arguments[0] !== 'number') {
			return CBuffer.apply(new CBuffer(arguments.length), arguments);
		} else {
			return new CBuffer(arguments[0]);
		}
	}
	// if no arguments, then nothing needs to be set
	if (arguments.length === 0)
	throw new Error('Missing Argument: You must pass a valid buffer length');
	// this is the same in either scenario
	this.size = this.start = 0;
	// set to callback fn if data is about to be overwritten
	this.overflow = null;
	// emulate Array based on passed arguments
	if (arguments.length > 1 || typeof arguments[0] !== 'number') {
		this.data = new Array(arguments.length);
		this.end = (this.length = arguments.length) - 1;
		this.push.apply(this, arguments);
	} else {
		this.data = new Array(arguments[0]);
		this.end = (this.length = arguments[0]) - 1;
	}
	// need to `return this` so `return CBuffer.apply` works
	return this;
}

function defaultComparitor(a, b) {
	return a == b ? 0 : a > b ? 1 : -1;
}

CBuffer.prototype = {
	// properly set constructor
	constructor : CBuffer,

	/* mutator methods */
	// pop last item
	pop : function () {
		var item;
		if (this.size === 0) return;
		item = this.data[this.end];
		// remove the reference to the object so it can be garbage collected
		delete this.data[this.end];
		this.end = (this.end - 1 + this.length) % this.length;
		this.size--;
		return item;
	},
	// push item to the end
	push : function () {
		var i = 0;
		// check if overflow is set, and if data is about to be overwritten
		if (this.overflow && this.size + arguments.length > this.length) {
			// call overflow function and send data that's about to be overwritten
			for (; i < this.size + arguments.length - this.length; i++) {
				this.overflow(this.data[(this.end + i + 1) % this.length], this);
			}
		}
		// push items to the end, wrapping and erasing existing items
		// using arguments variable directly to reduce gc footprint
		for (i = 0; i < arguments.length; i++) {
			this.data[(this.end + i + 1) % this.length] = arguments[i];
		}
		// recalculate size
		if (this.size < this.length) {
			if (this.size + i > this.length) this.size = this.length;
			else this.size += i;
		}
		// recalculate end
		this.end = (this.end + i) % this.length;
		// recalculate start
		this.start = (this.length + this.end - this.size + 1) % this.length;
		// return number current number of items in CBuffer
		return this.size;
	},
	// reverse order of the buffer
	reverse : function () {
		var i = 0,
			tmp;
		for (; i < ~~(this.size / 2); i++) {
			tmp = this.data[(this.start + i) % this.length];
			this.data[(this.start + i) % this.length] = this.data[(this.start + (this.size - i - 1)) % this.length];
			this.data[(this.start + (this.size - i - 1)) % this.length] = tmp;
		}
		return this;
	},
	// rotate buffer to the left by cntr, or by 1
	rotateLeft : function (cntr) {
		if (typeof cntr === 'undefined') cntr = 1;
		if (typeof cntr !== 'number') throw new Error("Argument must be a number");
		while (--cntr >= 0) {
			this.push(this.shift());
		}
		return this;
	},
	// rotate buffer to the right by cntr, or by 1
	rotateRight : function (cntr) {
		if (typeof cntr === 'undefined') cntr = 1;
		if (typeof cntr !== 'number') throw new Error("Argument must be a number");
		while (--cntr >= 0) {
			this.unshift(this.pop());
		}
		return this;
	},
	// remove and return first item
	shift : function () {
		var item;
		// check if there are any items in CBuff
		if (this.size === 0) return;
		// store first item for return
		item = this.data[this.start];
		// recalculate start of CBuffer
		this.start = (this.start + 1) % this.length;
		// decrement size
		this.size--;
		return item;
	},
	// sort items
	sort : function (fn) {
		this.data.sort(fn || defaultComparitor);
		this.start = 0;
		this.end = this.size - 1;
		return this;
	},
	// add item to beginning of buffer
	unshift : function () {
		var i = 0;
		// check if overflow is set, and if data is about to be overwritten
		if (this.overflow && this.size + arguments.length > this.length) {
			// call overflow function and send data that's about to be overwritten
			for (; i < this.size + arguments.length - this.length; i++) {
				this.overflow(this.data[this.end - (i % this.length)], this);
			}
		}
		for (i = 0; i < arguments.length; i++) {
			this.data[(this.length + this.start - (i % this.length) - 1) % this.length] = arguments[i];
		}
		if (this.length - this.size - i < 0) {
			this.end += this.length - this.size - i;
			if (this.end < 0) this.end = this.length + (this.end % this.length);
		}
		if (this.size < this.length) {
			if (this.size + i > this.length) this.size = this.length;
			else this.size += i;
		}
		this.start -= arguments.length;
		if (this.start < 0) this.start = this.length + (this.start % this.length);
		return this.size;
	},

	/* accessor methods */
	// return index of first matched element
	indexOf : function (arg, idx) {
		if (!idx) idx = 0;
		for (; idx < this.size; idx++) {
			if (this.data[(this.start + idx) % this.length] === arg) return idx;
		}
		return -1;
	},
	// return last index of the first match
	lastIndexOf : function (arg, idx) {
		if (!idx) idx = this.size - 1;
		for (; idx >= 0; idx--) {
			if (this.data[(this.start + idx) % this.length] === arg) return idx;
		}
		return -1;
	},

	// return the index an item would be inserted to if this
	// is a sorted circular buffer
	sortedIndex : function(value, comparitor, context) {
		comparitor = comparitor || defaultComparitor;
		var isFull = this.length === this.size,
			low = this.start,
			high = isFull ? this.size - 1 : this.size;

		// Tricky part is finding if its before or after the pivot
		// we can get this info by checking if the target is less than
		// the last item. After that it's just a typical binary search.
		if (low && comparitor.call(context, value, this.data[high]) > 0) {
			low = 0, high = this.end;
		}

		while (low < high) {
		  var mid = (low + high) >>> 1;
		  if (comparitor.call(context, value, this.data[mid]) > 0) low = mid + 1;
		  else high = mid;
		}
		return !isFull ? low :
			// http://stackoverflow.com/a/18618273/1517919
			(((low - this.start) % this.size) + this.size) % this.size;
	},

	/* iteration methods */
	// check every item in the array against a test
	every : function (callback, context) {
		var i = 0;
		for (; i < this.size; i++) {
			if (!callback.call(context, this.data[(this.start + i) % this.length], i, this))
				return false;
		}
		return true;
	},
	// loop through each item in buffer
	// TODO: figure out how to emulate Array use better
	forEach : function (callback, context) {
		var i = 0;
		for (; i < this.size; i++) {
			callback.call(context, this.data[(this.start + i) % this.length], i, this);
		}
	},
	// check items agains test until one returns true
	// TODO: figure out how to emuldate Array use better
	some : function (callback, context) {
		var i = 0;
		for (; i < this.size; i++) {
			if (callback.call(context, this.data[(this.start + i) % this.length], i, this))
				return true;
		}
		return false;
	},
	// calculate the average value of a circular buffer
	avg : function () {
		return this.size == 0 ? 0 : (this.sum() / this.size);
	},
	// loop through each item in buffer and calculate sum
	sum : function () {
		var index = this.size;
		var s = 0;
		while (index--) s += this.data[index];
		return s;
	},
	// loop through each item in buffer and calculate median
	median : function () {
		if (this.size === 0)
			return 0;
		var values = this.slice().sort(defaultComparitor);
		var half = Math.floor(values.length / 2);
		if(values.length % 2)
			return values[half];
		else
			return (values[half-1] + values[half]) / 2.0;
	},
	/* utility methods */
	// reset pointers to buffer with zero items
	// note: this will not remove values in cbuffer, so if for security values
	//       need to be overwritten, run `.fill(null).empty()`
	empty : function () {
		var i = 0;
		this.size = this.start = 0;
		this.end = this.length - 1;
		return this;
	},
	// fill all places with passed value or function
	fill : function (arg) {
		var i = 0;
		if (typeof arg === 'function') {
			while(this.data[i] = arg(), ++i < this.length);
		} else {
			while(this.data[i] = arg, ++i < this.length);
		}
		// reposition start/end
		this.start = 0;
		this.end = this.length - 1;
		this.size = this.length;
		return this;
	},
	// return first item in buffer
	first : function () {
		return this.data[this.start];
	},
	// return last item in buffer
	last : function () {
		return this.data[this.end];
	},
	// return specific index in buffer
	get : function (arg) {
		return this.data[(this.start + arg) % this.length];
	},
	isFull : function (arg) {
		return this.length === this.size;
	},
	// set value at specified index
	set : function (idx, arg) {
		return this.data[(this.start + idx) % this.length] = arg;
	},
	// return clean array of values
	toArray : function () {
		return this.slice();
	},
	// slice the buffer to an arraay
	slice : function (start, end) {
		var length = this.size;

		start = +start || 0;

		if (start < 0) {
			if (start >= end)
				return [];
			start = (-start > length) ? 0 : length + start;
		}

		if (end == null || end > length)
			end = length;
		else if (end < 0)
			end += length;
		else
			end = +end || 0;

		length = start < end ? end - start : 0;

		var result = Array(length);
		for (var index = 0; index < length; index++) {
			result[index] = this.data[(this.start + start + index) % this.length];
		}
		return result;
	}
};

if (typeof module === 'object' && module.exports) module.exports = CBuffer;
else global.CBuffer = CBuffer;

}(this));



      Polymer({
        is: "orov-video",
        properties: {
          videoSource: {type:Object},
          framesPerSecond: {type:Number},
          canvas: {type:Object, observer: '_canvasChanged'},
          videoMimeType: {type:String},
          location: {type:String},
          showStats: {type:Boolean, value:function(){return false;}}
        },
        behaviors: [namespace('behaviors').oROVStandard],
        detached: function(){
          this.shortCircuit=true;
        },
        packetVideo_initializationInProgress: false,
        registerEmitterHanlders: function(emitter){
          var self = this;
          this.shortCircuit=false;
          emitter.withHistory.on('settings-change.videosettings',function(settings){
            if (self.shortCircuit) {return;}
            self.showStats = settings.videosettings['show-stats'];
            
          });

          emitter.on('video.forward.get-canvas',function(callback){
            if (self.shortCircuit) {return;}            
            if (typeof(callback)==='function'){
              callback({forwardCanvas:this.canvas});
            }
          });
          emitter.withHistory.on('CameraRegistration',function(data){
            
            if (self.shortCircuit) {return;}            
            if (data.location!==self.location) return;
            //      self.rov.emit('CameraRegistration',{cameraLocation:'front', videoMimeType:'video/mp4', resolution:'1920x1080', framerate:30, sourcePort:service.port, sourceAddress:service.address});
            self.videoMimeType=data.videoMimeType;
            self.framesPerSecond=data.framerate;
            self.videoSource = data.sourceAddress;
          });

          //If we have segmented mp4 data streaming for this camera,
          //we go ahead and request the initalization packet and
          //init the camera before appending the raw data.

          emitter.on('x-h264-video.data',function(data){
            if (self.shortCircuit) {return;}            
            if (self.$$('#camera1')===null){
              return;
            }
            if(self.$$('#camera1').initialized){
              self.$$('#camera1').append(new Uint8Array(data));
            } else {
              if(!self.packetVideo_initializationInProgress){
                self.packetVideo_initializationInProgress = true;
                emitter.emit('request_Init_Segment',function(data){
                  self.$$('#camera1').init(new Uint8Array(data),function(){
                    packetVideo_initializationInProgress = false;
                    emitter.emit('video.videoElementAvailable',self.$$('#camera1').getVideoElement());
                  });
                });
                //timeout and try agian after 1 second
                setTimeout(function(){
                  self.packetVideo_initializationInProgress = false;
                },5000);
              }
            }
          });
// debugger;

          function Uint8ToString(u8a){
            var CHUNK_SZ = 0x8000;
            var c = [];
            for (var i=0; i < u8a.length; i+=CHUNK_SZ) {
              c.push(String.fromCharCode.apply(null, u8a.subarray(i, i+CHUNK_SZ)));
            }
            return c.join("");
          };

          //var buffer = new CBuffer(2);
          var image = new Image();
          var imageSrc = '';
          var tick = 2;

          var draw;
          var drawFrame;
          var canvas;
          var ctx;
          var proportionalHeight;
          var width;
          var height;

					var drawCounter = 0;

					setInterval(function(){
						console.log('FPS: ' + drawCounter);
						drawCounter = 0;
					}, 1000);

					var img = new Image;
					img.onload = function() {
							URL.revokeObjectURL(this.src);
							ctx.drawImage(img, 0, 0, canvas.width, proportionalHeight);
							drawCounter++;
					};

					var loadImage = function(frame, canvas, proportionalHeight) {
							var blob = new Blob([frame], {type: 'application/octet-binary'});
							var url = URL.createObjectURL(blob);
							img.src = url;
					};
          draw = function() {
            var frame = buffer.pop();
            if (frame ) {
							drawFrame(frame);
					}};
					drawFrame = function(frame) {
						if (frame.isDrawn == true) return;
						frame.isDrawn = true;

              if (!canvas || !width > 0 || !height > 0) {
								var blob = new Blob([frame.data], {type: 'application/octet-binary'});
								var url = URL.createObjectURL(blob);
								image.onload = function() {

									self.$$('#camera1').src = url; // set first frame
									canvas = self.$$('#camera1').videocanvas;
									var style = window.getComputedStyle(canvas.parentElement, null);
									width = parseInt(style.getPropertyValue('width'));
									height = parseInt(style.getPropertyValue('height'));
									proportionalHeight = width * image.height / image.width;
									ctx = canvas.getContext('2d');
									self.$$('#camera1').stop();
									self.$$('#camera1').isHidden = true;
									URL.revokeObjectURL(url);
								}
								image.src = url;

                
              }            
              if (canvas && (canvas.width== 0 || canvas.height == 0)) {
                canvas.width = width;
                canvas.height = height;
              }
							if (canvas && canvas.width > 0 && canvas.height > 0 ) 
								loadImage(frame.data, canvas, proportionalHeight);
            }

					var mjpegDrawIntervall;

          emitter.on('x-motion-jpeg.data',function(frame){
            //console.log(frame.timestamp);
            if (self.shortCircuit) {return;}            
            if (self.$$('#camera1')===null){
              return;
            }
//            buffer.push({data: frame, isDrawn: false});
						//drawFrame({data: frame, isDrawn: false});
						window.postMessage({type: 'draw', data: frame, isDrawn: false}, '*', [frame]);
            
              
							// if (!mjpegDrawIntervall) {
							// 	// mjpegDrawIntervall = setInterval(draw, 1000 /  self.framesPerSecond );
							// 	mjpegDrawIntervall = setInterval(draw, 10);
							// }

            // }
          });
					window.onmessage = function(message) {
						if (message.data.type == 'draw') {
							drawFrame(message.data);
						}
					}


        },
        _canvasChanged: function(){
          if (this.eventEmitter!==undefined){
            this.eventEmitter.emit('video.forward.canvas-changed',this.canvas);
          }
        },
        displayPlayer(mimeType,playerType){
          return mimeType==playerType;
        }
      })
    })();
  </script>

</dom-module>
